#ifndef __WEBVTTXX_STRING__
# define __WEBVTTXX_STRING__

# include <webvtt/string.h>
# include "base"

# define UTF16_LEFT_TO_RIGHT   (0x200E)
# define UTF16_RIGHT_TO_LEFT   (0x200F)
# define UTF16_NO_BREAK_SPACE  (0x00A0)

namespace WebVTT
{

class String
{
public:
  inline String() {
    webvtt_init_string( &string );
  }

  inline String( webvtt_string *other ) {
    webvtt_copy_string( &string, other );
  }
  
  inline String( const byte *buffer, int len = -1 ) {   
    if( WEBVTT_FAILED( webvtt_create_string_with_text( &string, buffer, len ) ) ) {
      // TODO: Throw exception on errors.
    }
  }

  inline String( const char *buffer, int len = -1 ) {
    if( WEBVTT_FAILED( webvtt_create_string_with_text( &string, 
        reinterpret_cast<const byte *>( buffer ), len ) ) ) {
      // TODO: Throw exception on errors.
    }
  }

  /**
   * Copy constructors
   */
  inline String( const String &other ) {
    webvtt_copy_string( &string, &other.string );
  }

  inline String &operator=( const String &other ) {
    webvtt_copy_string( &string, &other.string );
    return *this;
  }

  inline ~String() {
    webvtt_release_string( &string );
  }

  inline void detach() {
    webvtt_string_detach( &string );
  }

  inline bool isEmpty() const {
    return webvtt_string_is_empty( &string ) == 1;
  }

  uint16 utf16At( int offset, uint16 &highSurrogate ) const {
    const byte *b = utf8();
    const byte *end = b + length();
    if( webvtt_skip_utf8( &b, end, offset ) ) {
      return webvtt_utf8_to_utf16( b, end, &highSurrogate );
    }
    return 0;
  }

  uint16 utf16At( int offset ) const {
    uint16 high;
    return utf16At( offset, high );
  }

  uint32 utf32At( int offset ) const {
    uint16 hi, lo = utf16At( offset, hi );
    return toUtf32( lo, hi );
  }

  static bool isSurrogate( uint16 ch ) {
    return ( ( ch & 0xF800 ) == 0xD800 );
  }

  static bool requiresSurrogate( uint32 ch ) {
    return ch >= 0x10000;
  }

  static bool isSurrogateLead( uint16 ch ) {
    return ( ch & 0x400 ) == 0;
  }

  static bool isSurrogateTrail( uint16 ch ) {
    return ( ch & 0x400 ) != 0;
  }

  static uint32 toUtf32( uint16 low, uint16 high ) {
    return ( uint32 )high << 10 + low - 0x35FDC00;
  }

  static uint32 toUtf32( uint16 ch ) {
    if( !isSurrogate( ch ) ) {
      return ( uint32 )ch;
    }
    return 0xFFFD;
  }

  inline const byte *utf8() const {
    return webvtt_string_text(&string);
  }

  inline uint length() const {
    return webvtt_string_length(&string);
  }

  inline uint capacity() const {
    return webvtt_string_capacity(&string);
  }

  /* Count of Unicode codepoints in string */
  inline uint charCount() const {
    return (uint)webvtt_utf8_chcount( utf8(), utf8() + length() );
  }

  inline String &append( byte ch, webvtt_status &result ) {
    result = webvtt_string_putc( &string, ch );
    return *this;
  }

  inline String &append( byte ch ) {
    webvtt_status ignored;
    return append( ch, ignored );
  }

  inline String &append( const char *str, webvtt_status &result ) {
    result = webvtt_string_append( &string,
      reinterpret_cast<const byte *>( str ), -1 );
    return *this;
  }

  inline String &append( const char *str, int len, webvtt_status &result ) {
    result = webvtt_string_append( &string,
      reinterpret_cast<const byte *>( str ), len );
    return *this;
  }

  inline String &append( const char *str, int len = -1 ) {
    webvtt_status ignored;
    return append( str, len, ignored );
  }

  inline String &append( const String &other, webvtt_status &result ) {
    result = webvtt_string_append( &string, other.utf8(), -1 );
    return *this;
  }

  inline String &append( const String &other, int len, webvtt_status &result ) {
    result = webvtt_string_append( &string, other.utf8(), len );
    return *this;
  }

  inline String &append( const String &other, int len = -1 ) {
    webvtt_status ignored;
    return append( other, len, ignored );
  }

private:
  webvtt_string string;
};

class StringList
{
public:

  inline StringList() : stringList( 0 ) { }
  inline StringList( webvtt_stringlist *other ) : stringList( other ) {}

  inline String operator[]( uint i ) const
  {
    if( stringList && i <= stringList->length ) {
      return String( &stringList->items[ i ] );
    }
    return String();
  }

  inline String stringAt( uint i ) {
    return (*this)[ i ];
  }

  inline uint length() {
    return stringList ? stringList->length : 0;
  }

  inline uint alloc() {
    return stringList ? stringList->alloc : 0;
  }

private:
  webvtt_stringlist *stringList;
};

}

#endif
